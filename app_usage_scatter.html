<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>앱 사용 시간 분석 (10/27 - 11/02)</title>
  <style>
    :root {
      --bg: #f5f0e8;
      --panel: rgba(251,247,240,0.92);
      --text: #1d1d1b;
      --shadow: rgba(29,29,27,0.12);
      --brand-black: #0f0f0f;
      --brand-mid: #34322f;
    }
    body {
      margin: 0;
      font-family: 'IBM Plex Sans', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
      color: var(--text);
      background: var(--bg);
      min-height: 100vh;
      letter-spacing: 0.01em;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .page {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .chart-container {
      position: relative;
      width: min(82vmin, 780px);
      height: min(82vmin, 780px);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
      margin: 0 auto;
    }
    .chart-container svg {
      width: 100%;
      height: 100%;
    }
    .tooltip {
      position:absolute;
      background: rgba(15,15,15,0.94);
      color:#fdfaf5;
      padding: 13px 18px;
      border-radius:12px;
      box-shadow: 0 18px 40px rgba(15,15,15,0.35);
      z-index:20;
      display:none;
      pointer-events: none;
      border: 1px solid rgba(255,255,255,0.08);
      letter-spacing: 0.04em;
    }
    .tooltip .name { font-size: 13px; font-weight: 600; margin-bottom: 6px; letter-spacing: 0.08em; text-transform: uppercase; }
    .tooltip .row { font-size: 11px; color:rgba(248,244,236,0.88); margin: 2px 0; white-space: nowrap; }
    svg#chart {
      border-radius: 50%;
      background: transparent;
    }
    text { font-family: inherit; }
  </style>
  </head>
<body>
  <div class="page">
    <div class="chart-container">
      <svg id="chart" width="880" height="880" viewBox="0 0 880 880" preserveAspectRatio="xMidYMid meet" role="img" aria-label="앱 사용 시간대 원형 시각화"></svg>
        <div id="tooltip" class="tooltip">
          <div class="name"></div>
          <div class="row date"></div>
          <div class="row time"></div>
        <div class="row duration"></div>
          <div class="row category"></div>
      </div>
    </div>
  </div>
  <script>
    const usageEvents = [
      { date: '2024-11-02', app: 'Figma', start: '2024-11-02T09:05', duration: 72, category: '생산성 및 금융' },
      { date: '2024-11-02', app: 'Google Chrome', start: '2024-11-02T11:20', duration: 48, category: '기타' },
      { date: '2024-11-02', app: '카카오톡', start: '2024-11-02T13:10', duration: 26, category: '소셜 미디어' },
      { date: '2024-11-02', app: 'Cursor', start: '2024-11-02T20:40', duration: 94, category: '생산성 및 금융' },
      { date: '2024-11-02', app: 'Finder', start: '2024-11-02T22:25', duration: 12, category: '기타' },
      { date: '2024-11-01', app: 'Cursor', start: '2024-11-01T08:15', duration: 125, category: '생산성 및 금융' },
      { date: '2024-11-01', app: 'Google Chrome', start: '2024-11-01T10:50', duration: 56, category: '기타' },
      { date: '2024-11-01', app: 'Figma', start: '2024-11-01T13:05', duration: 52, category: '생산성 및 금융' },
      { date: '2024-11-01', app: '카카오톡', start: '2024-11-01T18:20', duration: 34, category: '소셜 미디어' },
      { date: '2024-10-31', app: 'Figma', start: '2024-10-31T09:30', duration: 160, category: '생산성 및 금융' },
      { date: '2024-10-31', app: 'Cursor', start: '2024-10-31T14:10', duration: 102, category: '생산성 및 금융' },
      { date: '2024-10-31', app: 'Google Chrome', start: '2024-10-31T16:40', duration: 64, category: '기타' },
      { date: '2024-10-31', app: '카카오톡', start: '2024-10-31T21:10', duration: 42, category: '소셜 미디어' },
      { date: '2024-10-30', app: 'Figma', start: '2024-10-30T08:40', duration: 158, category: '생산성 및 금융' },
      { date: '2024-10-30', app: 'Cursor', start: '2024-10-30T11:45', duration: 120, category: '생산성 및 금융' },
      { date: '2024-10-30', app: 'Google Chrome', start: '2024-10-30T15:10', duration: 90, category: '기타' },
      { date: '2024-10-30', app: 'us.zoom.videomeetings', start: '2024-10-30T19:00', duration: 63, category: '생산성 및 금융' },
      { date: '2024-10-30', app: '카카오톡', start: '2024-10-30T22:20', duration: 44, category: '소셜 미디어' },
      { date: '2024-10-29', app: 'Figma', start: '2024-10-29T07:50', duration: 210, category: '생산성 및 금융' },
      { date: '2024-10-29', app: 'YouTube', start: '2024-10-29T12:10', duration: 58, category: '엔터테인먼트' },
      { date: '2024-10-29', app: 'Google Chrome', start: '2024-10-29T15:30', duration: 55, category: '기타' },
      { date: '2024-10-29', app: '카카오톡', start: '2024-10-29T18:40', duration: 40, category: '소셜 미디어' },
      { date: '2024-10-29', app: 'Cursor', start: '2024-10-29T21:15', duration: 28, category: '생산성 및 금융' },
      { date: '2024-10-28', app: 'Cursor', start: '2024-10-28T09:05', duration: 110, category: '생산성 및 금융' },
      { date: '2024-10-28', app: 'Google Chrome', start: '2024-10-28T11:15', duration: 84, category: '기타' },
      { date: '2024-10-28', app: 'Figma', start: '2024-10-28T14:00', duration: 70, category: '생산성 및 금융' },
      { date: '2024-10-28', app: '카카오톡', start: '2024-10-28T19:20', duration: 24, category: '소셜 미디어' },
      { date: '2024-10-27', app: 'Google Chrome', start: '2024-10-27T10:50', duration: 112, category: '기타' },
      { date: '2024-10-27', app: 'Cursor', start: '2024-10-27T13:40', duration: 120, category: '생산성 및 금융' },
      { date: '2024-10-27', app: 'Figma', start: '2024-10-27T16:10', duration: 70, category: '생산성 및 금융' },
      { date: '2024-10-27', app: '카카오톡', start: '2024-10-27T21:35', duration: 36, category: '소셜 미디어' },
      { date: '2024-10-27', app: '메모', start: '2024-10-27T23:20', duration: 28, category: '생산성 및 금융' }
    ];

    const categoryStyles = {
      '생산성 및 금융': { fill: '#111111', stroke: 'rgba(17,17,17,0.65)' },
      '기타': { fill: '#3c3936', stroke: 'rgba(17,17,17,0.54)' },
      '소셜 미디어': { fill: '#6b6762', stroke: 'rgba(17,17,17,0.4)' },
      '엔터테인먼트': { fill: '#9a958d', stroke: 'rgba(17,17,17,0.3)' }
    };

    const getStyleForCategory = (category) => categoryStyles[category] || { fill: '#b0aba2', stroke: 'rgba(17,17,17,0.35)' };

    const svg = document.getElementById('chart');
    const viewBox = svg.viewBox && svg.viewBox.baseVal;
    const width = viewBox && viewBox.width ? viewBox.width : Number(svg.getAttribute('width'));
    const height = viewBox && viewBox.height ? viewBox.height : Number(svg.getAttribute('height'));
    const centerX = width / 2;
    const centerY = height / 2;
    const outerRadius = Math.min(width, height) / 2 - 80;
    const innerRadius = 110;

    const parseDate = (value) => new Date(value);
    const uniqueDates = Array.from(new Set(usageEvents.map(d => d.date))).sort((a,b) => parseDate(a) - parseDate(b));
    const ringSpacing = uniqueDates.length > 1 ? (outerRadius - innerRadius) / (uniqueDates.length - 1) : 0;
    const hourAngles = Array.from({ length: 24 }, (_, hour) => hour);

    const tooltip = document.getElementById('tooltip');
    const tooltipName = tooltip.querySelector('.name');
    const tooltipDate = tooltip.querySelector('.date');
    const tooltipTime = tooltip.querySelector('.time');
    const tooltipDuration = tooltip.querySelector('.duration');
    const tooltipCat = tooltip.querySelector('.category');

    const toAngle = (dateString) => {
      const date = parseDate(dateString);
      const minutes = date.getHours() * 60 + date.getMinutes();
      return (minutes / (24 * 60)) * Math.PI * 2 - Math.PI / 2;
    };

    const getRadius = (date) => {
      if (uniqueDates.length === 1) return innerRadius;
      const idx = uniqueDates.indexOf(date);
      return innerRadius + idx * ringSpacing;
    };

    const polarToCartesian = (angle, radius) => ({
      x: centerX + Math.cos(angle) * radius,
      y: centerY + Math.sin(angle) * radius
    });

    const append = (tag, attrs = {}, parent = svg) => {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
      parent.appendChild(el);
      return el;
    };

    const gridGroup = append('g', { 'stroke-linecap': 'round' });
    const ringGroup = append('g', {}, gridGroup);
    const hourGroup = append('g', {}, gridGroup);
    const markerGroup = append('g', { opacity: '0.75' });

    const baseRingCount = uniqueDates.length * 4 + 24;
    for (let i = 0; i <= baseRingCount; i++) {
      const radius = innerRadius + (i / baseRingCount) * (outerRadius - innerRadius);
      append('circle', {
        cx: centerX,
        cy: centerY,
        r: radius,
        fill: 'none',
        stroke: i % 4 === 0 ? 'rgba(15,15,15,0.15)' : 'rgba(15,15,15,0.08)',
        'stroke-width': i % 4 === 0 ? '0.9' : '0.45',
        'stroke-dasharray': i % 4 === 0 ? 'none' : '2 8'
      }, ringGroup);
    }

    const dayLinkGroup = append('g', { fill: 'none' });
    const connectorGroup = append('g', { stroke: '#111111', 'stroke-width': '1.1', 'stroke-linecap': 'round', opacity: '0.7' });
    const dataGroup = append('g');

    hourAngles.forEach(hour => {
      const angle = (hour / 24) * Math.PI * 2 - Math.PI / 2;
      const { x, y } = polarToCartesian(angle, outerRadius);
      append('line', {
        x1: centerX,
        y1: centerY,
        x2: x,
        y2: y,
        stroke: hour % 3 === 0 ? 'rgba(15,15,15,0.22)' : 'rgba(15,15,15,0.1)',
        'stroke-width': hour % 3 === 0 ? '1.4' : '0.65',
        'stroke-dasharray': hour % 3 === 0 ? 'none' : '4 10',
        opacity: hour % 3 === 0 ? '0.9' : '0.6'
      }, hourGroup);

      if (hour % 3 === 0) {
        const labelPoint = polarToCartesian(angle, outerRadius + 30);
        const text = append('text', {
          x: labelPoint.x,
          y: labelPoint.y,
          'text-anchor': 'middle',
          'dominant-baseline': 'middle',
          fill: 'var(--brand-mid)',
          'font-size': '11',
          opacity: '0.72',
          'font-weight': '500',
          'letter-spacing': '0.08em'
        }, hourGroup);
        text.textContent = hour === 0 ? '0시' : `${hour}시`;
      }
    });

    uniqueDates.forEach((date, index) => {
      const radius = getRadius(date);
      const labelPoint = polarToCartesian(Math.PI / 2, radius + 4);
      const text = append('text', {
        x: labelPoint.x,
        y: labelPoint.y + 16,
        'text-anchor': 'middle',
        fill: 'var(--brand-mid)',
        'font-size': '11',
        'font-weight': index === uniqueDates.length - 1 ? '600' : '500',
        opacity: index === uniqueDates.length - 1 ? '0.88' : '0.58',
        'letter-spacing': '0.12em'
      }, markerGroup);
      const dateLabel = new Date(date);
      text.textContent = `${dateLabel.getMonth() + 1}/${dateLabel.getDate()}`;
    });

    append('circle', {
      cx: centerX,
      cy: centerY,
      r: innerRadius - 36,
      fill: 'rgba(15,15,15,0.05)'
    }, gridGroup);

    const pointsByDate = new Map();

    usageEvents.forEach(event => {
      const angle = toAngle(event.start);
      const baseRadius = getRadius(event.date);
      const radius = baseRadius;
      const { x, y } = polarToCartesian(angle, radius);
      const size = Math.max(3, Math.min(13, Math.sqrt(event.duration) * 1.05));
      const style = getStyleForCategory(event.category);

      const baseStrokeWidth = size > 7 ? 1.2 : 0.8;
      const circle = append('circle', {
        cx: x,
        cy: y,
        r: size,
        fill: style.fill,
        opacity: '0.78',
        stroke: style.stroke,
        'stroke-width': baseStrokeWidth
      }, dataGroup);

      append('line', {
        x1: centerX,
        y1: centerY,
        x2: x,
        y2: y
      }, connectorGroup);

      if (!pointsByDate.has(event.date)) {
        pointsByDate.set(event.date, []);
      }
      pointsByDate.get(event.date).push({ x, y, angle, radius: baseRadius });

      circle.style.cursor = 'pointer';
      circle.style.mixBlendMode = 'multiply';
      circle.dataset.baseStrokeWidth = String(baseStrokeWidth);

      circle.addEventListener('mouseenter', () => {
        circle.setAttribute('opacity', '1');
        circle.setAttribute('stroke-width', String(baseStrokeWidth + 0.6));
        tooltipName.textContent = event.app;
        tooltipDate.textContent = `날짜: ${event.date}`;
        const startDate = parseDate(event.start);
        const hh = startDate.getHours().toString().padStart(2, '0');
        const mm = startDate.getMinutes().toString().padStart(2, '0');
        tooltipTime.textContent = `시작: ${hh}:${mm}`;
        tooltipDuration.textContent = `지속: ${Math.floor(event.duration / 60)}시간 ${event.duration % 60}분`;
        tooltipCat.textContent = `카테고리: ${event.category}`;
        tooltip.style.display = 'block';
      });

      circle.addEventListener('mousemove', (evt) => {
        const rect = svg.getBoundingClientRect();
        tooltip.style.left = `${evt.clientX - rect.left + 20}px`;
        tooltip.style.top = `${evt.clientY - rect.top + 20}px`;
      });

      circle.addEventListener('mouseleave', () => {
        circle.setAttribute('opacity', '0.78');
        circle.setAttribute('stroke-width', circle.dataset.baseStrokeWidth);
        tooltip.style.display = 'none';
      });
    });

    pointsByDate.forEach(points => {
      if (points.length < 2) return;
      const sorted = points.slice().sort((a, b) => a.angle - b.angle);
      let d = `M${sorted[0].x.toFixed(2)} ${sorted[0].y.toFixed(2)}`;
      for (let i = 1; i < sorted.length; i++) {
        const prev = sorted[i - 1];
        const curr = sorted[i];
        let delta = curr.angle - prev.angle;
        if (delta < 0) delta += Math.PI * 2;
        const largeArcFlag = delta > Math.PI ? 1 : 0;
        d += ` A ${curr.radius.toFixed(2)} ${curr.radius.toFixed(2)} 0 ${largeArcFlag} 1 ${curr.x.toFixed(2)} ${curr.y.toFixed(2)}`;
      }
      append('path', {
        d,
        stroke: '#111111',
        'stroke-width': '1.1',
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round',
        opacity: '0.75'
      }, dayLinkGroup);
    });
  </script>
</body>
</html>





